<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="https://maxweber.github.io/" rel="self" type="application/rss+xml"/><title>The blog of Max Weber</title><link>https://maxweber.github.io/</link><description>A blog about software and business development</description><lastBuildDate>Tue, 20 Aug 2019 12:16:45 +0200</lastBuildDate><generator>clj-rss</generator><item><guid>https://maxweber.github.io/blog/2019-08-09-introducing-db-view-part-3</guid><link>https://maxweber.github.io/blog/2019-08-09-introducing-db-view-part-3</link><title>Introducing db-view - Part 3</title><description>&lt;p&gt;&lt;a href='https://maxweber.github.io/blog/2019-07-25-introducing-db-view-part-1'&gt;part 1&lt;/a&gt; of this blog post series introduced the db-view approach and discussed its trade-offs. &lt;a href='https://maxweber.github.io/blog/2019-08-05-introducing-db-view-part-2'&gt;part 2&lt;/a&gt; showed a &lt;a href='https://github.com/maxweber/todomvc-db-view'&gt;TodoMVC example app&lt;/a&gt; that uses the db-view approach. This part explains how to do side effects in a db-view application.&lt;/p&gt;&lt;p&gt;Side effects are a necessary evil within most applications. The todo app discussed in &lt;a href='https://maxweber.github.io/blog/2019-08-05-introducing-db-view-part-2'&gt;part 2&lt;/a&gt; would be pretty useless without side effects, like marking a todo as done or creating a new one. Functional programming tries to push these side effects to the "edges of the system", meaning it tries to maximize the percentage of side-effect-free (pure) functions. &lt;a href='https://www.datomic.com/'&gt;Datomic&lt;/a&gt; takes this to a whole nother level by applying this principle to create a database system that only needs one stateful &lt;a href='https://www.infoq.com/presentations/Value-Values/'&gt;place&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The first iteration of the db-view approach used the common way to perform side effects within a web application, it sends a HTTP post to the corresponding API endpoint. This one either performs the side effect (like doing a database transaction) or returns a response with a validation error. The 'either ... or' in the previous sentence already indicates that this API endpoint does two things. Therefore it is not as &lt;a href='https://www.infoq.com/presentations/Simple-Made-Easy/'&gt;simple&lt;/a&gt; as it could be. I took it apart by moving the validation into the side-effect-free part of the application. The result was the command concept of the db-view approach that is discussed below.&lt;/p&gt;&lt;p&gt;The concept of "commands" is nothing new, it is often used in the context of &lt;a href='https://martinfowler.com/eaaDev/EventSourcing.html'&gt;event sourcing&lt;/a&gt; and &lt;a href='https://martinfowler.com/bliki/CQRS.html'&gt;CQRS&lt;/a&gt;.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; CQRS stands for &lt;strong&gt;Command Query Responsibility Segregation&lt;/strong&gt;. It's a   pattern that I first heard described by &lt;a href='https://twitter.com/gregyoung'&gt;Greg Young&lt;/a&gt;.   At its heart is the notion that you can use a different model to update information   than the model you use to read information. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;a href='https://martinfowler.com/bliki/CQRS.html'&gt;Martin Fowler&lt;/a&gt;&lt;/p&gt;&lt;p&gt;A command that marks a todo as done looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;{:command/type :todo/done!
 :db/id 17592186045419}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The server encrypts this command map before returning it as part of the db-view output:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;{:todo/list
 {:todo/list-items
  &amp;#91;{:db/id 17592186045419,
    :todo/title &amp;quot;Write a blog post&amp;quot;,
    :todo/done! &amp;quot;g7RWatF6ldi0Xm6LT/vxhiHIKpw+UzF/OU/iVQDmu0zyTDmRZe7ZdIMPBS2YKVooSivGx6+K9xiHgMa7imqibD1RqFoqFrv+X8TEq0YQUlPJcYjSwiN9DTOUZwrOtPX3Veum8OPUljte/5Eu7924aQrJN2mEI2kfG1DF8eGOOqw=&amp;quot;
    }&amp;#93;
 }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The frontend can send this encrypted command to the '/command' API endpoint to perform the side effect. Through the encryption the server can ensure that the frontend cannot manipulate the command map (assuming the encryption is safe). Thereby most validations can be done in advance, when the command map is created. Even if a command like &lt;code&gt;:todo/done!&lt;/code&gt; has no user input, the server can validate, if the current user is allowed to perform this command. You could for example share your todo list with a colleague as read-only version. The server can ensure that this colleague cannot mark your todos as done, simply by not including the encrypted &lt;code&gt;:todo/done!&lt;/code&gt; command in the db-view output. In this way many authorization aspects become very simple to handle. The frontend for example just have to check, if the corresponding command map is in the db-view output to decide, if the corresponding button for the command should be enabled or disabled.&lt;/p&gt;&lt;p&gt;An example for a command that has an user input is &lt;code&gt;:todo/edit!&lt;/code&gt;. It let's the user change the title of a todo. To receive the corresponding encrypted commmand the frontend requests the '/db-view/get' API endpoint with this payload:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;{:todo/edit {:db/id 17592186045419
             :todo/title &amp;quot;New Title&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The response with the db-view output looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;{:todo/edit {:todo/edit &amp;quot;MkVO6khjHd5ZcqojwEpwaFRdjTPNmNiDyFJMHEzVGUUhQ1jq30NYQtIJzMrJkqxNiQJLbgHK7iK+IVsjZPhkU0w0yBqzpy1RwSJVjiNrT16XhGjxAcVWX7S0/vBT659NH9VeBnP6nSfmAnmi/mnbWF4200ZmjuVEQssbMSGMGwpDYfbJwMcl/I0BliT1HnHsKvtbjR9Q6hOzEJwDuTnVvw==&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A validation of the &lt;code&gt;:todo/title&lt;/code&gt; could for example enforce a minimum length. Let's say we send this db-view input:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;{:todo/edit {:db/id 17592186045419
             :todo/title &amp;quot;Ne&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then we would receive this db-view output:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;{:todo/edit {:error &amp;quot;Title must be longer than 2 characters!&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Instead of the encrypted command the server sends the validation error. A more generic API would rather return an error id with some extra information like the expected minimal length. The frontend would then assemble an appropriate error message. Here the error message is directly included in the response, since a db-view API is exclusively written for a single frontend. The internationalization of the error messages can then also be done on the server-side.&lt;/p&gt;&lt;p&gt;Another common topic in the context of APIs are batch requests, meaning executing multiple API calls in one request. This reduces the latency, since only one instead of multiple requests are used. On the other hand things like returning validation errors get more complicated. For the db-view approach batch requests are unnecessary, since you can always introduce a new command type that combines multiple side effects. In this way it is straight forward to execute all side-effects in a single database transaction. Furthermore it reduces the possibilities for an attacker to mess with the order of the API calls or commands.&lt;/p&gt;&lt;p&gt;A drawback of the command concept is that it offers more possibilities for replay attacks. A simple mechanism that is already included in the example app, can help to prevent replay attacks. The server adds an &lt;a href='https://en.wikipedia.org/wiki/Universally_unique_identifier'&gt;UUID&lt;/a&gt; as &lt;code&gt;:command/uuid&lt;/code&gt; entry to each command map, while the command handler adds this &lt;code&gt;:command/uuid&lt;/code&gt; to the transaction entity. There is a unique constraint on the &lt;code&gt;:command/uuid&lt;/code&gt; Datomic attribute. Meaning a second transaction with the same &lt;code&gt;:command/uuid&lt;/code&gt; will fail. Whereby it is ensured that this command is executed at most once (to avoid replay attacks).&lt;/p&gt;&lt;p&gt;This was the last part to introduce the db-view approach. I hope you find it useful and I would be happy to receive feedback (weber.maximilian at gmail.com).&lt;/p&gt;</description><pubDate>Fri, 09 Aug 2019 00:00:00 +0200</pubDate></item><item><guid>https://maxweber.github.io/blog/2019-08-05-introducing-db-view-part-2</guid><link>https://maxweber.github.io/blog/2019-08-05-introducing-db-view-part-2</link><title>Introducing db-view - Part 2</title><description>&lt;p&gt;In &lt;a href='https://maxweber.github.io/blog/2019-07-25-introducing-db-view-part-1'&gt;part 1&lt;/a&gt; I've talked about the db-view approach that has different trade-offs in comparison to a REST API. In essence you decide to develop your backend API endpoint with a single frontend app in mind. Thereby your API endpoint and frontend tends to stay &lt;a href='https://www.infoq.com/presentations/Simple-Made-Easy/'&gt;simple&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;This part is about the example app that I've developed for this blog post series. It implements the well-known &lt;a href='http://todomvc.com/'&gt;TodoMVC&lt;/a&gt; example, an app to manage todo items. In comparison to many other TodoMVC implementations out there, it implements the frontend and the backend. It is a core principle of the db-view approach that you design your API exclusively for one frontend app, instead of providing a more generic API. The latter one introduces &lt;a href='https://maxweber.github.io/blog/2019-06-15-approaching-the-web-after-tomorrow-part-3'&gt;various complexities&lt;/a&gt; which needs to be solved, despite the fact that they are not strictly required for your app.&lt;/p&gt;&lt;p&gt;The source code for the example app can be found here:&lt;/p&gt;&lt;p&gt;&lt;a href='https://github.com/maxweber/todomvc-db-view'&gt;https://github.com/maxweber/todomvc-db-view&lt;/a&gt;&lt;/p&gt;&lt;p&gt;It uses Clojure for the backend and ClojureScript for the frontend. The &lt;a href='https://leiningen.org/'&gt;Leiningen&lt;/a&gt; build tool is used for the Clojure part, while &lt;a href='https://github.com/thheller/shadow-cljs'&gt;shadow-cljs&lt;/a&gt; is used for the frontend. The example &lt;a href='https://github.com/maxweber/todomvc-db-view/blob/master/README.md'&gt;README&lt;/a&gt; describes how to start the app and the required tools.&lt;/p&gt;&lt;p&gt;The API endpoint &lt;code&gt;/db-view/get&lt;/code&gt; is used to receive the &lt;code&gt;:db-view/output&lt;/code&gt; map from the server. This is the corresponding frontend code:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;ns todomvc-db-view.db-view.get
  &amp;#40;:require &amp;#91;cljs.core.async :as a&amp;#93;
            &amp;#91;cljs-http.client :as http&amp;#93;
            &amp;#91;todomvc-db-view.state.core :as state&amp;#93;&amp;#41;
  &amp;#40;:require-macros &amp;#91;cljs.core.async.macros :refer &amp;#91;go&amp;#93;&amp;#93;&amp;#41;&amp;#41;

;; Concept:
;;
;; Gets and refreshes the db-view from the server. Provides the server
;; API endpoint '/db-view/get' with the `:db-view/input` map from the
;; app state. Receives the `:db-view/output` map in the API response
;; and stores it in the app state. Reagent will trigger a rerender of
;; all UI components which depend on changed parts of the
;; `:db-view/output`.

&amp;#40;defn get-view
  &amp;quot;Provides the server API endpoint '/db-view/get' with the
   `:db-view/input` map from the app state and returns the API response
   that contains the `:db-view/output` map.&amp;quot;
  &amp;#91;state-value&amp;#93;
  &amp;#40;go
    &amp;#40;let &amp;#91;response &amp;#40;&amp;lt;! &amp;#40;http/request
                        {:request-method :post
                         :url &amp;quot;/db-view/get&amp;quot;
                         ;; NOTE: for a production app add
                         ;;       authorization here and prefer the
                         ;;       Transit format:
                         :edn-params &amp;#40;:db-view/input state-value&amp;#41;}&amp;#41;&amp;#41;&amp;#93;
      &amp;#40;:body response&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn refresh!
  &amp;quot;Provides the server API endpoint '/db-view/get' with the
   `:db-view/input` map from the app state, receives the
   `:db-view/output` map from the API response and stores it in the app
   state.&amp;quot;
  &amp;#91;&amp;#93;
  &amp;#40;go
    &amp;#40;:db-view/output
     &amp;#40;swap! state/state
            assoc
            :db-view/output
            &amp;#40;&amp;lt;! &amp;#40;get-view @state/state&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the recent years I tend to use a light form of &lt;a href='https://en.wikipedia.org/wiki/Literate_programming'&gt;Literate programming&lt;/a&gt;, where you provide more explanation of the logic in a natural language. Therefore you find the explanation of the source code in the 'Concept' header, the comments and the doc-strings of the functions above.&lt;/p&gt;&lt;p&gt;The app state is hold in a &lt;a href='https://github.com/reagent-project/reagent'&gt;Reagent&lt;/a&gt; atom:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;ns todomvc-db-view.state.core
  &amp;#40;:require &amp;#91;reagent.core :as r&amp;#93;&amp;#41;&amp;#41;

;; Concept:
;;
;; Namespace with the Reagent atom `state` that holds the global app
;; state of this ClojureScript app.

&amp;#40;def initial-state-value
  {:db-view/input {:todo/list {}}}&amp;#41;

&amp;#40;defonce state
  &amp;#40;r/atom initial-state-value&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The counterpart for the &lt;code&gt;/db-view/get&lt;/code&gt; API endpoint on the server-side looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;ns todomvc-db-view.db-view.get
  &amp;#40;:require &amp;#91;datomic.api :as d&amp;#93;
            &amp;#91;todomvc-db-view.util.edn :as edn&amp;#93;
            &amp;#91;todomvc-db-view.db-view.todo-list :as todo-list&amp;#93;
            &amp;#91;todomvc-db-view.db-view.todo-edit :as todo-edit&amp;#93;
            &amp;#91;todomvc-db-view.db-view.todo-new :as todo-new&amp;#93;&amp;#41;&amp;#41;

;; Concept:
;;
;; Provides the API endpoint to get the db-view. The request body
;; contains the parameters to query the database to assemble the
;; `:db-view/output` map, that contains the required data for the
;; current active UI parts. This value is returned in the response
;; body and the client stores it in the Reagent app state atom, where
;; the UI components can access it.

&amp;#40;defn get-view
  &amp;quot;Main entry point to gather the `:db-view/output` map for the
   client. Based on the given Datomic database value `db` and the
   `:db-view/input` map from the client.&amp;quot;
  &amp;#91;db db-view-input&amp;#93;
  &amp;#40;merge
   &amp;#40;todo-list/get-view db
                       db-view-input&amp;#41;
   &amp;#40;todo-edit/get-view db
                       db-view-input&amp;#41;
   &amp;#40;todo-new/get-view db
                      db-view-input&amp;#41;
   ;; NOTE: add other db-view parts here.
   &amp;#41;&amp;#41;

&amp;#40;defn ring-handler
  &amp;quot;Ring handler to get the `:db-view/output` map for the given
   `:db-view/input` map in the `request` body.&amp;quot;
  &amp;#91;db request&amp;#93;
  &amp;#40;when &amp;#40;and &amp;#40;= &amp;#40;:request-method request&amp;#41; :post&amp;#41;
             &amp;#40;= &amp;#40;:uri request&amp;#41; &amp;quot;/db-view/get&amp;quot;&amp;#41;&amp;#41;
    ;; NOTE: for a production app rather use
    ;;       &amp;#91;Transit&amp;#93;&amp;#40;https://github.com/cognitect/transit-format&amp;#41;
    ;;       here instead of EDN:
    &amp;#40;let &amp;#91;db-view-input &amp;#40;edn/read-string &amp;#40;slurp &amp;#40;:body request&amp;#41;&amp;#41;&amp;#41;&amp;#93;
      ;; NOTE: for a production app do the appropriate authorization
      ;;       checks:
      &amp;#40;edn/response
       &amp;#40;get-view db
                 db-view-input&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I already included the commands into the example app, which are used to perform side-effects like adding a new todo-item. Commands will be explained in detail in the next blog post. Now let's have a look at the namespace that contains the db-view implementation for the todo list UI:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;ns todomvc-db-view.db-view.todo-list
  &amp;#40;:require &amp;#91;datomic.api :as d&amp;#93;&amp;#41;&amp;#41;

;; Concept:
;;
;; The db-view part for the todo list UI.

&amp;#40;defn q-all
  &amp;quot;Queries all todo-item entities and pulls the attributes which are
   required for todo list UI.&amp;quot;
  &amp;#91;db&amp;#93;
  &amp;#40;d/q
   '&amp;#91;:find
     &amp;#91;&amp;#40;pull ?e
            &amp;#91;:db/id :todo/title :todo/done&amp;#93;&amp;#41; ...&amp;#93;
     :where
     &amp;#91;?e :todo/title&amp;#93;&amp;#93;
   db&amp;#41;&amp;#41;

&amp;#40;defn get-view
  &amp;quot;Returns the db-view for the todo list UI.&amp;quot;
  &amp;#91;db db-view-input&amp;#93;
  &amp;#40;when-let &amp;#91;params &amp;#40;:todo/list db-view-input&amp;#41;&amp;#93;
    &amp;#40;let &amp;#91;all &amp;#40;q-all db&amp;#41;
          {:keys &amp;#91;active completed&amp;#93;} &amp;#40;group-by &amp;#40;fn &amp;#91;todo-item&amp;#93;
                                                 &amp;#40;if &amp;#40;:todo/done todo-item&amp;#41;
                                                   :completed
                                                   :active&amp;#41;&amp;#41;
                                               all&amp;#41;
          todo-items &amp;#40;case &amp;#40;:todo/filter params&amp;#41;
                       :active
                       active
                       :completed
                       completed
                       all&amp;#41;&amp;#93;
      {:todo/list {:todo/list-items todo-items
                   :todo/active-count &amp;#40;count active&amp;#41;
                   :todo/completed-count &amp;#40;count completed&amp;#41;}}&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the code above I removed the command-related parts for the purpose of this blog post, but you can already find it in the &lt;a href='https://github.com/maxweber/todomvc-db-view/blob/master/src/clj/todomvc_db_view/db_view/todo_list.clj'&gt;Github repo&lt;/a&gt;. Altogether the code is really straightforward:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;it runs a Datomic query that gets all todo-items with the attributes  required for the todo list UI&lt;/li&gt;&lt;li&gt;groups the query results into active and completed todo-items&lt;/li&gt;&lt;li&gt;returns the group that was requested via the &lt;code&gt;:todo/filter&lt;/code&gt; parameter as &lt;code&gt;:todo/list-items&lt;/code&gt;&lt;/li&gt;&lt;li&gt;counts the active and completed todo-items (this information is used  in the bottom bar of the todo list UI)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The notify part of the app enables the real-time or rather auto-update behaviour of the example app. To try it out, just open the example app in two browser windows, then you see that changes in one window also get replicated in the other window. On the client side the code looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;ns todomvc-db-view.db-view.notify
  &amp;#40;:require &amp;#91;cljs-http.client :as http&amp;#93;
            &amp;#91;todomvc-db-view.db-view.get :as get&amp;#93;
            &amp;#91;cljs.core.async :as a&amp;#93;&amp;#41;
  &amp;#40;:require-macros &amp;#91;cljs.core.async.macros :refer &amp;#91;go-loop&amp;#93;&amp;#93;&amp;#41;&amp;#41;

;; Concept:
;;
;; Listens for changes in the Datomic transaction log, which affect
;; the current logged-in user. Uses HTTP long polling to allow the API
;; endpoint on the server to push a message. The server will notify
;; the client everytime, when a transaction contains something
;; relevant for the current logged-in user.
;;
;; Due to this mechanism the client can show updates, which were issued
;; by the server &amp;#40;a finished background job for example or a change by
;; another user&amp;#41;.

&amp;#40;defn start-listening
  &amp;quot;Starts a go-loop that opens a long-polling request to the
   '/db-view/notify' API endpoint. Refreshes the `:db-view/output` map
   in the app state, when it receives a HTTP 200 response. Sleeps for a
   short moment, when it receives an error response to not DDoS the
   server in the case of a server issue.&amp;quot;
  &amp;#91;&amp;#93;
  &amp;#40;go-loop &amp;#91;&amp;#93;
    &amp;#40;let &amp;#91;response &amp;#40;&amp;lt;! &amp;#40;http/request
                         {:request-method :post
                          :url &amp;quot;/db-view/notify&amp;quot;}&amp;#41;&amp;#41;&amp;#93;
      &amp;#40;if &amp;#40;= &amp;#40;:status response&amp;#41;
             200&amp;#41;
        &amp;#40;&amp;lt;! &amp;#40;get/refresh!&amp;#41;&amp;#41;
        &amp;#40;&amp;lt;! &amp;#40;a/timeout 2000&amp;#41;&amp;#41;&amp;#41;
      &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The server counterpart looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;ns todomvc-db-view.db-view.notify
  &amp;#40;:require &amp;#91;org.httpkit.server :as httpkit&amp;#93;
            &amp;#91;datomic.api :as d&amp;#93;
            &amp;#91;todomvc-db-view.util.edn :as edn&amp;#93;&amp;#41;&amp;#41;

;; Concept:
;;
;; Provides an API endpoint that allows clients to listen for changes
;; in the Datomic transaction log, which affect their current
;; logged-in user.
;;
;; Thereby the client can refresh the `:db-view/output` map as soon as
;; it is notified by this API endpoint. HTTP long polling is used here
;; to allow the server to push a message to the client. It is less
;; complex to implement in comparison to WebSockets. Furthermore the
;; low latency and reduced payload size of WebSockets is not required
;; for this use case.

&amp;#40;defonce client-listeners-state
  ;; holds the httpkit channels of the clients, which are waiting for
  ;; a db-view notify:
  &amp;#40;atom {}&amp;#41;&amp;#41;

&amp;#40;defn ring-handler
  &amp;quot;Ring-handler for the '/db-view/notify' API endpoint.&amp;quot;
  &amp;#91;request&amp;#93;
  &amp;#40;when &amp;#40;and &amp;#40;= &amp;#40;:request-method request&amp;#41; :post&amp;#41;
             &amp;#40;= &amp;#40;:uri request&amp;#41; &amp;quot;/db-view/notify&amp;quot;&amp;#41;&amp;#41;
    ;; NOTE: for a production app add an authentication check here:
    &amp;#40;httpkit/with-channel request channel
      ;; register the user's browser session in the
      ;; `client-listeners-state`:
      &amp;#40;swap! client-listeners-state
             assoc
             channel
             channel&amp;#41;
      &amp;#40;httpkit/on-close channel
                        &amp;#40;fn &amp;#91;status&amp;#93;
                          ;; remove the user's browser session from
                          ;; the `client-listeners-state` as soon as
                          ;; the channel is closed, meaning the user
                          ;; has closed the browser tab or the network
                          ;; connection was interrupted:
                          &amp;#40;swap! client-listeners-state
                                 dissoc
                                 channel&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn notify
  &amp;quot;A Datomic transaction listener that notifies all user browser
   sessions, where the user was affected by the transaction of the
   `tx-report`.&amp;quot;
  &amp;#91;tx-report&amp;#93;
  &amp;#40;let &amp;#91;basis-t &amp;#40;d/basis-t &amp;#40;:db-after tx-report&amp;#41;&amp;#41;
        response &amp;#40;edn/response
                  {:db/basis-t basis-t}&amp;#41;&amp;#93;
    ;; NOTE: for a production app only send notifications to the users
    ;;       which are affected by this `tx-report`:
    &amp;#40;doseq &amp;#91;channel &amp;#40;vals @client-listeners-state&amp;#41;&amp;#93;
      &amp;#40;httpkit/send! channel
                     response&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As already mentioned in the note above you would normally only notify the connected users (client-listeners) which are affected by the current Datomic transaction report. For example if your app supports teams and one user makes a change on the team's todo list, only the team mates which are currently online would be notified.&lt;/p&gt;&lt;p&gt;Datomic has this great feature that you can access the transaction log and even receive push updates of new transactions via the &lt;a href='https://docs.datomic.com/on-prem/clojure/index.html#datomic.api/tx-report-queue'&gt;&lt;code&gt;datomic.api/tx-report-queue&lt;/code&gt;&lt;/a&gt;. Most likely you will have multiple web servers, which response to db-view requests and executes commands (which transacts Datomic transactions). With the help of Datomic's transaction queue it does not matter to which server the client has opened the long-polling HTTP request, since all servers will be informed of the new transaction and initiate the necessary notification for an affected user.&lt;/p&gt;&lt;p&gt;The db-view approach also works for other databases than Datomic. But most of them do not provide access to a transaction queue. A do-it-yourself alternative to push the notifications is an effort that should not be underestimated. Therefore I would recommend services like &lt;a href='https://pusher.com/'&gt;Pusher&lt;/a&gt; or &lt;a href='https://www.pubnub.com/'&gt;Pubnub&lt;/a&gt;, where you can push messages to the user's web browser, without building the required infrastructure yourself. The server would then send the notifications to the affected users right after it has transacted the corresponding Datomic transaction.&lt;/p&gt;&lt;p&gt;As already mentioned, the next blog post will cover the concept of commands in the context of a db-view application.&lt;/p&gt;</description><pubDate>Mon, 05 Aug 2019 00:00:00 +0200</pubDate></item><item><guid>https://maxweber.github.io/blog/2019-07-25-introducing-db-view-part-1</guid><link>https://maxweber.github.io/blog/2019-07-25-introducing-db-view-part-1</link><title>Introducing db-view - Part 1</title><description>&lt;p&gt;In my previous blog post series &lt;a href='https://maxweber.github.io/blog/2019-06-04-approaching-the-web-after-tomorrow'&gt;Approaching The Web After Tomorrow&lt;/a&gt; I've talked about how I tried to implement the idea that &lt;a href='https://twitter.com/nikitonsky'&gt;Nikita&lt;/a&gt; described in his blog post called &lt;a href='https://tonsky.me/blog/the-web-after-tomorrow/'&gt;The Web After Tomorrow&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;In &lt;a href='https://maxweber.github.io/blog/2019-06-04-approaching-the-web-after-tomorrow'&gt;part 1 of Approaching The Web After Tomorrow&lt;/a&gt; I talked about how we used DataScript, Datomic and Clojure(Script) to build a real-time app for our SaaS product &lt;a href='https://www.storrito.com'&gt;Storrito.com&lt;/a&gt; and what performance challenge the first implementation yielded. &lt;a href='https://maxweber.github.io/blog/2019-06-08-approaching-the-web-after-tomorrow-part-2'&gt;Part 2&lt;/a&gt; was about some ideas I had to solve this performance challenge. Finally &lt;a href='https://maxweber.github.io/blog/2019-06-15-approaching-the-web-after-tomorrow-part-3'&gt;Part 3&lt;/a&gt; was about what difficulties you can avoid by creating your API for exclusively one frontend app and that big organizations tends to separate developers into frontend and backend developer teams.&lt;/p&gt;&lt;p&gt;For this blog post series I've prepared an example to introduce you to an approach I named "db-view". During my search for a good example use case, I noticed again the deep division that splits our industry into frontend and backend software development. You probably all know the de-facto standard example of almost every frontend framework: the &lt;a href='http://todomvc.com/'&gt;TodoMVC&lt;/a&gt;, an app to manage todo entries. New to me was that there is also a collection of example backend implementations for this todo app: &lt;a href='https://www.todobackend.com/'&gt;todobackend.com&lt;/a&gt;. Interestingly enough it is hard to find examples that implements both, the frontend and the backend. This is also the case for another popular collection of examples: &lt;a href='https://realworld.io/'&gt;realworld.io&lt;/a&gt; or how they call it "the mother of all demo apps", an exemplary fullstack clone of &lt;a href='https://medium.com/'&gt;Medium.com&lt;/a&gt;. This project even enforces the segregation of the frontend and the backend by requiring that all implementations follow the same &lt;a href='https://github.com/gothinkster/realworld/tree/master/api'&gt;API specification&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;This leads to the benefit that you can freely exchange the frontend and the backend implementations. But this segregation might not yield the optimal trade-offs for your small developer team, that tries to implement your current project in time and budget. Such a generic API has dozens of requirements, which are hard to solve (see &lt;a href='https://maxweber.github.io/blog/2019-06-15-approaching-the-web-after-tomorrow-part-3'&gt;Part 3 of the previous blog series&lt;/a&gt;). Furthermore your API endpoint becomes more complex the more apps and systems use it, since all of them might need a slightly different set of database fields or functionality from your server.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; Developers know the benefits of everything and the trade-offs of   nothing. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;  Rich Hickey (&lt;a href='https://youtu.be/rI8tNMsozo0?t=744'&gt;source&lt;/a&gt;)&lt;/p&gt;&lt;p&gt;The db-view approach choose different trade-offs in comparison to a REST API. In essence you decide to develop your backend API endpoint with a single frontend app in mind. All returned data is tailor-made for your particular frontend implementation. Instead of implementing a generic todo entries API endpoint, you return the data in a shape that is designed specifically for your todo list UI component. Thereby this shape can stay simple, since it doesn't have to satisfy and intertwine the requirements of multiple UI parts (or different apps).&lt;/p&gt;&lt;p&gt;You only need a single API endpoint for the read-related (meaning no side-effects) part of app. Let's use the URL path &lt;code&gt;/db-view/get&lt;/code&gt; for this API endpoint. It receives a map via the request body and returns a map in the response body. &lt;a href='https://github.com/edn-format/edn'&gt;EDN&lt;/a&gt; is used as data format for the example below:&lt;/p&gt;&lt;p&gt;&lt;em&gt;Example request body:&lt;/em&gt;&lt;pre&gt;&lt;code class="clojure"&gt;{:todo/list {}}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;Example response body:&lt;/em&gt;&lt;pre&gt;&lt;code class="clojure"&gt;{:todo/list {:todo/list-items
             &amp;#91;{:db/id 17592186045418
               :todo/title &amp;quot;Create an example&amp;quot;
               :todo/done true}
              {:db/id 17592186045419
               :todo/title &amp;quot;Write a blog post&amp;quot;
               :todo/done false}
              {:db/id 17592186045420
               :todo/title &amp;quot;Publish the blog post&amp;quot;
               :todo/done false}&amp;#93;
             :todo/active-count 2}
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;The corresponding UI is the one of the &lt;a href='http://todomvc.com/'&gt;TodoMVC&lt;/a&gt; examples and it looks like this:&lt;/p&gt;&lt;p&gt;&lt;img src="/img/todo-all.png" alt="todo-all" /&gt;&lt;/p&gt;&lt;p&gt;The request claims that server should return the &lt;code&gt;:todo/list&lt;/code&gt; part of the db-view. The response contains the data that is needed to render the todo list UI of your frontend. The &lt;code&gt;:todo/active-count&lt;/code&gt; is used to display the number of active todo entries, which are still not done.&lt;/p&gt;&lt;p&gt;To only show the todo entries that are already done, you send the request:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;{:todo/list {:todo/filter :completed}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And receive the response:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;{:todo/list {:todo/list-items
             &amp;#91;{:db/id 17592186045418
               :todo/title &amp;quot;Create an example&amp;quot;
               :todo/done true}&amp;#93;
             :todo/active-count 2}
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Once again the response data is tailor-made for the todo list UI that only shows the completed todo entries now:&lt;/p&gt;&lt;p&gt;&lt;img src="/img/todo-complete.png" alt="todo-completed" /&gt;&lt;/p&gt;&lt;p&gt;Note that the &lt;code&gt;:todo/active-count&lt;/code&gt; ("2 items left") is still shown in the bottom bar, that's why it is still included in the response. Most likely your app shows multiple UI parts at once. Let's say your app always displays the email address of the current user at the top of the page:&lt;/p&gt;&lt;p&gt;&lt;em&gt;Example request:&lt;/em&gt;&lt;pre&gt;&lt;code class="clojure"&gt;{:todo/list {:todo/filter :completed}
 :user/info {}}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;Example response:&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;{:todo/list {:todo/list-items
             &amp;#91;{:db/id 17592186045418
               :todo/title &amp;quot;Create an example&amp;quot;
               :todo/done true}&amp;#93;
             :todo/active-count 2}
 :user/info {:user/email &amp;quot;max@example.com&amp;quot;}
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here the &lt;code&gt;:user/info&lt;/code&gt; entry in the request tells the server to include the information of the current user in the response body. The &lt;code&gt;:user/info&lt;/code&gt; entry in the response contains the &lt;code&gt;:user/email&lt;/code&gt; to display it at the top of the page.&lt;/p&gt;&lt;p&gt;Let's pretend multiple people are using this todo app simultaneously. When a user adds a new todo entry, how do the other users receive the update. In the case of a "classic" web application the other users would need to click the browser's refresh button to receive the latest state from the server that includes the new todo entry.&lt;/p&gt;&lt;p&gt;The db-view approach uses a similar mechanism, with the difference that the user do not have to press the refresh button, a kind of auto-refresh if you like. While a "classic" web application would transfer the arguments to the server via the query parameters of the URL, a db-view frontend stores these parameters in a map (JSON or EDN) and sends them via a POST request to the server. To refresh our app with the latest state of the server, we just repeat this POST request with the same parameters as last time.&lt;/p&gt;&lt;p&gt;To receive the update with the new todo entry, the dumbest implementation would just poll the server every second. Of course normally you would use long-polling, websockets, server-sent events or a service like &lt;a href='https://pusher.com/channels'&gt;Pusher&lt;/a&gt; to send a signal to the client. This signal does not contain any payload, it just tells the client to do a refresh.&lt;/p&gt;&lt;p&gt;To avoid a full page refesh, the frontend needs to use a virtual dom library (like React). The example for this blog post series uses &lt;a href='https://github.com/reagent-project/reagent'&gt;Reagent&lt;/a&gt; (also React-based) to implement the UI. The complete frontend app state is held in a single (Reagent) &lt;a href='https://clojuredocs.org/clojure.core/atom'&gt;atom&lt;/a&gt;. The input parameters for the db-view are stored under the key &lt;code&gt;:db-view/input&lt;/code&gt; in the app state and are send as request body to the &lt;code&gt;/db-view/get&lt;/code&gt; API endpoint. The response body (also a map) is stored under the key &lt;code&gt;:db-view/output&lt;/code&gt; in the app state. From there the UI components can access the data that has been retrieved from the server. As soon as the app state is updated Reagent will rerender the corresponding UI components and the user will see the most recent state.&lt;/p&gt;&lt;p&gt;In the &lt;a href='https://elixir-lang.org/'&gt;elixir&lt;/a&gt; community a related approach called &lt;a href='https://github.com/phoenixframework/phoenix_live_view'&gt;Phoenix LiveView&lt;/a&gt; is emerging that does even more on the server-side, since it also does a kind of virtual dom diffing on the server-side. The trade-off is that you can implement most of the app on the server-side, but you need to store the client state on the server and deal with the latency. Luckily Clojure has a good story for client-side development due to ClojureScript.  Therefore you can at least use the same programming language for the frontend and the backend. By doing more on the server-side Phoenix LiveView and db-view both reduce the number of pitfalls due to the fact that you can not trust the client (e.g. an attacker can modify the client source code or send fake requests to your API).&lt;/p&gt;&lt;p&gt;More on that in the next blog posts, which will also provide a detailed look on the source code of the db-view example todo app. Furthermore we we will also learn how to implement side-effects in the context of a db-view application.&lt;/p&gt;</description><pubDate>Thu, 25 Jul 2019 00:00:00 +0200</pubDate></item><item><guid>https://maxweber.github.io/blog/2019-06-15-approaching-the-web-after-tomorrow-part-3</guid><link>https://maxweber.github.io/blog/2019-06-15-approaching-the-web-after-tomorrow-part-3</link><title>Approaching The Web After Tomorrow - Part 3</title><description>&lt;p&gt;This blog post series is about my attempt to implement &lt;a href='https://tonsky.me/blog/the-web-after-tomorrow/'&gt;The Web After Tomorrow&lt;/a&gt; that &lt;a href='https://twitter.com/nikitonsky'&gt;Nikita&lt;/a&gt; described in his &lt;a href='https://tonsky.me/blog/the-web-after-tomorrow/'&gt;blog post&lt;/a&gt; back in 2015.&lt;/p&gt;&lt;p&gt;In &lt;a href='https://maxweber.github.io/blog/2019-06-04-approaching-the-web-after-tomorrow'&gt;part 1&lt;/a&gt; I talked about how we used DataScript, Datomic and Clojure(Script) to build a real-time app for our SaaS product &lt;a href='https://www.storrito.com'&gt;Storrito.com&lt;/a&gt; and what performance challenge the first implementation yielded. &lt;a href='https://maxweber.github.io/blog/2019-06-08-approaching-the-web-after-tomorrow-part-2'&gt;Part 2&lt;/a&gt; was about some ideas I had to solve this performance challenge.&lt;/p&gt;&lt;p&gt;This part will be about reconsidering some common trade-offs of web application development to bring up a solution that has the potential to save a lot of effort and accidential complexity, especially for small teams of developers.&lt;/p&gt;&lt;p&gt;I must admit that I had no good idea for a couple of months how to solve the described performance issue, without generating tons of effort for our team. Oftentimes it is valuable to make a pause, work on other topics and &lt;a href='https://www.youtube.com/watch?v=f84n5oFoZBc'&gt;let your brain do some background processing&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;One morning I woke up with the question, why it still so much &lt;a href='https://www.infoq.com/presentations/Simple-Made-Easy/'&gt;simpler&lt;/a&gt; to build a classic server-side web application in comparison to a single-page web application (SPA). Virtual DOM frameworks like React already made a step in the right direction by providing a very simple mental model (at its core) to create user interfaces. In essence they allow you to build your UI like a classic website: you start with a blank screen and the browser renders the complete HTML. You do not have to think about what is currently shown on the screen and how to modify the DOM to the desired new UI state.&lt;/p&gt;&lt;p&gt;A classic server-side web application often does one or more database queries to generate the HTML string that is sent to the browser (let's say to render a HTML table of customer addresses for example). Maybe there is another simple mental model waiting for us, if we design the API for our SPA more like how things are done within a classic server-side web application.&lt;/p&gt;&lt;p&gt;Instead of serving the complete HTML for a webpage, we could just return the required data from the database query results via the API response and let the client do the HTML rendering.&lt;/p&gt;&lt;p&gt;Nothing new you might think in comparison to a REST-based API, but the key difference is that this API response is only meant for this single webpage (like the customers table UI). REST APIs often have endpoints like '/customers', where you get a JSON response with customer entries from the database. But there the accidential complexity starts to emerge:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;what parts of your client application use this endpoint.&lt;/li&gt;&lt;li&gt;what fields of the customer table do they need (first-name,  last-name, birthday etc.).&lt;/li&gt;&lt;li&gt;one UI element also needs the date of the customer's last order, which is  not part of the '/customers' API endpoint (n+1 problem).&lt;/li&gt;&lt;li&gt;is the logged-in user authorized to see these customer entries&lt;/li&gt;&lt;li&gt;which developer teams in your organization are using this  '/customers' API endpoint.&lt;/li&gt;&lt;li&gt;where can they find your API documentation.&lt;/li&gt;&lt;li&gt;if it is part of a public API, even more questions arise.&lt;/li&gt;&lt;li&gt;often a different authentication is required (like OAuth2)&lt;/li&gt;&lt;li&gt;is the change backwards-compatible or is it a breaking change  (&lt;a href='https://www.youtube.com/watch?v=oyLBGkS5ICk'&gt;btw don't do this&lt;/a&gt;) and  you need to version your API endpoint (like '/v2/customers').&lt;/li&gt;&lt;li&gt;has the quota of the external API caller been reached.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I could continue with more points for a while, but I guess you get the point, you need to take care of dozens of other concerns that have nothing to do with returning the data to render your particular page. Furthermore your API endpoint will tend to get more complex, if the number of API consumers grows. Each consumer may need a different set of fields or related entities from the database. Your API endpoint stays &lt;a href='https://www.infoq.com/presentations/Simple-Made-Easy/'&gt;simpler&lt;/a&gt;, if you only use it for one particular page of your client-side web application:&lt;/p&gt;&lt;p&gt;&lt;img src="/img/simple-vs-complex-api.svg" alt="Simple vs complex" /&gt;&lt;/p&gt;&lt;p&gt;Another point that leads to myriads of challenges is the 'n + 1' problem. Like in the example mentioned above, where you might like to render a list of customers and the date of their last order, but the latter is not part of the '/customers' API endpoint. Therefore you need to do n more requests for each customer to the '/orders' endpoint to receive this date. This introduces quite a lot of latency to your singe-page application, since instead of 1 request you need to make n+1 requests.&lt;/p&gt;&lt;p&gt;Technologies like &lt;a href='https://graphql.org/'&gt;GraphQL&lt;/a&gt; and &lt;a href='https://netflix.github.io/falcor/'&gt;Falcor&lt;/a&gt; were designed to avoid this 'n + 1' problem, they allow to fetch all the required data with a single HTTP request. Furthermore the client developer can choose what fields of the requested resources (like '/customers') should be returned.&lt;/p&gt;&lt;p&gt;So why not just use GraphQL. As the name already implies GraphQL was designed as a query language. Similar like backend developers can query the database (with SQL for example), frontend developers can use the GraphQL API to do queries. It was created by an organization (Facebook), where it is common that teams are divided by backend and frontend developers. A GraphQL API serves many different frontend teams or rather their client applications (web, mobile apps etc.). Therefore all the challenges described in the list above need to be addressed. Also the challenges of a public API arise, since even if Facebook didn't offer a public GraphQL API for 3rd-party developers, the sheer amount of frontend developer teams in their organization, would require similar practices.&lt;/p&gt;&lt;p&gt;Don't get me wrong, GraphQL is a good solution for an organization like Facebook. The question is, if it is the right technology for a team of 1-5 developers in a small company. Normally I don't like to quote so-called "laws" like the one of &lt;a href='https://en.wikipedia.org/wiki/Conway%27s_law'&gt;Conway&lt;/a&gt;, but here it describes the situation very well:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; organizations which design systems ... are constrained to produce designs which are copies of the communication structures of these organizations. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;So GraphQL is a good fit for Facebook, since the separation of frontend and backend developers are baked into their organization and their communication structures.&lt;/p&gt;&lt;p&gt;We are a small team of 4 developers, we have no other types of employees at the moment, so we also do all the business, marketing, product design, customer support etc. But more important all of us do frontend and backend development. We do not need to file a Jira ticket into the backlog of a backend team to get an additional field into a REST-API endpoint (like '/customers'). We can just do this on our own. All of our source code lives in a single Git repository. Therefore the frontend and backend source code for a new feature is part of the same pull request. Even our build process always releases a new version of our frontend and backend at the same time. A technology like GraphQL probably does not provide the optimal trade-offs for a small organization like ours, if it was designed with organizations in mind which are magnitudes larger.&lt;/p&gt;&lt;p&gt;The next blog post will finally get a little bit more technical and show how to implement such a single-page web application that API works more like a classic web application.&lt;/p&gt;</description><pubDate>Sat, 15 Jun 2019 00:00:00 +0200</pubDate></item><item><guid>https://maxweber.github.io/blog/2019-06-08-approaching-the-web-after-tomorrow-part-2</guid><link>https://maxweber.github.io/blog/2019-06-08-approaching-the-web-after-tomorrow-part-2</link><title>Approaching The Web After Tomorrow - Part 2</title><description>&lt;p&gt;This blog post series is about my attempt to implement &lt;a href='https://tonsky.me/blog/the-web-after-tomorrow/'&gt;The Web After Tomorrow&lt;/a&gt; that &lt;a href='https://twitter.com/nikitonsky'&gt;Nikita&lt;/a&gt; described in his &lt;a href='https://tonsky.me/blog/the-web-after-tomorrow/'&gt;blog post&lt;/a&gt; back in 2015.&lt;/p&gt;&lt;p&gt;This part is about some ideas I had to solve the performance challenge that was described in &lt;a href='https://maxweber.github.io/blog/2019-06-04-approaching-the-web-after-tomorrow'&gt;part 1&lt;/a&gt;.&lt;/p&gt;&lt;h2 id="load&amp;#95;only&amp;#95;relevant&amp;#95;data"&gt;Load only relevant data&lt;/h2&gt;&lt;p&gt;Maybe the quickest fix would have been to try to only load datoms which are relevant for the current UI state. This idea is also part of Nikita's proposed solution:&lt;/p&gt;&lt;p&gt;&lt;img src="/img/the-web-after-tomorrow_filters.png" alt="Filters" /&gt;&lt;/p&gt;&lt;p&gt;(source: http://tonsky.me/blog/the-web-after-tomorrow/)&lt;/p&gt;&lt;p&gt;While this is certainly doable, it increases the accidentally complexity, at least in our case. Our DataScript queries had access to the full database portion of the user, this is the layer "Accessible data" in the illustration above. Therefore nothing needed to be fetched from the "Whole database" in advance to ensure that a query will "see" everything it needs to yield the correct result.&lt;/p&gt;&lt;p&gt;However our performance challenge was that the amount of "Accessible data" for a lot of our users had grown too big. Therefore we need to make a change to only load the relevant data for the current UI state, which is the "Looking at data" in illustration above.&lt;/p&gt;&lt;p&gt;The "Looking at data" is only a subset of the "Accessible data" (which is a subset of the "Whole database"). You could also say that the "Looking at data" is derived from the "Accessible data" by applying a filter function for example. Another way would be to execute a database query (SQL, datalog etc.) to the "Accessible data" that yields the "Looking at data". In the context of a database this is often called a view. These views need to be kept up to date as soon as relevant data is transacted into the database. This tends to cause performance challenges. That's why there are a lot of optimizations available for this topic (like materialized views for example).&lt;/p&gt;&lt;p&gt;I do not want to dive deeper into this topic here. I only like to mention a few interesting approaches:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/'&gt;Turning the database inside-out&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://www.youtube.com/watch?v=ZgqFlowyfTA'&gt;Reactive Datalog for Datomic&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://www.clockworks.io/2018/09/13/incremental-datalog.html'&gt;Incremental Datalog with Differential Dataflows&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;While all these topics are super interesting to me, they have one thing in common:&lt;/p&gt;&lt;p&gt;They are probably not the core of your business, except your company is offering a database product or service. Thereby you end up spending a lot of effort building a half-backed database, instead of focusing on improving the app or service that your company is offering.&lt;/p&gt;&lt;h2 id="a&amp;#95;rest&amp;#95;api"&gt;A REST API&lt;/h2&gt;&lt;p&gt;Another way would have been to switch back to a "classic" REST API. This would have mean that we need to write custom logic to mimic the behaviour of our current real-time web app. A few examples:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;An user can upload new images or videos to Storrito and the new  entries automatically appear in his gallery UI.&lt;/li&gt;&lt;li&gt;Also his team members will see those new entries in their gallery UI  instantly.&lt;/li&gt;&lt;li&gt;Our servers convert an uploaded video into the right format,  meanwhile the UI displays a hint that the video is currently  converted.&lt;/li&gt;&lt;li&gt;The Storrito web app informs the user with a notification, when the  server posts his story and decreases the amount of remaining story  posts (before the user has to buy new ones).&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;As developers we have grown to like the automatic real-time behaviour of our web app. We just need to transact a change to Datomic and the UI of the affected user(s) will reflect this change.&lt;/p&gt;&lt;p&gt;To notify the user that we have posted his story, the server transacts the date of execution to the database entity that represents this scheduled story post. The new datoms are pushed to the browser of the user and are added to his local Datascript database. This triggers a re-execution of the corresponding datalog queries and this causes that the affected React UI elements are re-rendered. The user then sees the corresponding notification UI about the successful story post. Also other parts of the UI like the amount of remaining story posts updates automatically. In non real-time web apps this is often inconsistent, most of us have probably seen some messenger app, where the unread message icon does not disappear, after you have opened the new message(s). Only a page reload makes the unread message icon go away.&lt;/p&gt;&lt;h2 id="your&amp;#95;own&amp;#95;database&amp;#95;index"&gt;Your own database index&lt;/h2&gt;&lt;p&gt;Instead of loading the datoms, another interesting idea is to provide the front-end with access to the database index. It would only cover the datoms, which are owned by the user (the "Accessible data"). Datomic's database index is implemented with a data structure that is similar to the persistent immutable data structures of Clojure. Both are tree data structures, but the one of Datomic must have way more entries per node to compensate the IO latency, similar to a B-Tree index of a relational database. Due to the immutable nature of this data structure it could be cached without any complex invalidations. This caching could also be done in the browser, whereby it would become something similar like a Datomic peer. Regrettably, Datomic's closed-source model makes this direction impractical.&lt;/p&gt;&lt;p&gt;An alternative is the so-called &lt;a href='https://github.com/datacrypt-project/hitchhiker-tree'&gt;Hitchhiker Tree&lt;/a&gt;, which is open-source and offers similar characteristics like the Datomic index data structure. Transit JSON could be used as storage format, so that the browser can read it directly (Datomic is using the &lt;a href='https://github.com/Datomic/fressian'&gt;Fressian&lt;/a&gt; format).&lt;/p&gt;&lt;p&gt;However in the end you would run into the same issue like described above that you implement a half-baked database, which is a huge distraction from the core of your business. Another limitation is that the XHR request in the browser is asynchronous (the synchronous version is deprecated). To be able to fetch more index segments via XHR requests the DataScript API would need to become asynchronous too. And this would also change the developer experience a lot, since the entity API would not be practical anymore.&lt;/p&gt;&lt;h2 id="graphql"&gt;GraphQL&lt;/h2&gt;&lt;p&gt;There is no doubt that &lt;a href='https://graphql.org/'&gt;GraphQL&lt;/a&gt; is in vogue nowadays and it has been adapted by many organizations already. Despite the good ecosystem (there is even a &lt;a href='https://github.com/walmartlabs/lacinia'&gt;Clojure GraphQL lib&lt;/a&gt;) and tools which are available for GraphQL, it still means a lot of effort to implement a GraphQL back-end. Especially for a small developer team (like ours) this can become a huge burden. Therefore I thought about, if we would pick the optimal &lt;a href='https://www.reddit.com/r/programming/comments/3va6x0/programmers_know_the_benefits_of_everything_and/'&gt;trade-offs&lt;/a&gt; for our small company, if we would adopt a technology like GraphQL (or a similar one like the &lt;a href='http://edn-query-language.org/'&gt;EDN Query Language&lt;/a&gt;).&lt;/p&gt;&lt;p&gt;For that reason the next part of this blog post series will be about reconsidering some common trade-offs of modern web development. Picking different trade-offs can yield huge productivity gains for small teams of full stack developers, which do not have a split between front-end and back-end developer teams.&lt;/p&gt;</description><pubDate>Sat, 08 Jun 2019 00:00:00 +0200</pubDate></item><item><guid>https://maxweber.github.io/blog/2019-06-04-approaching-the-web-after-tomorrow</guid><link>https://maxweber.github.io/blog/2019-06-04-approaching-the-web-after-tomorrow</link><title>Approaching The Web After Tomorrow - Part 1</title><description>&lt;p&gt;My current venture is &lt;a href='https://storrito.com/'&gt;Storrito.com&lt;/a&gt; where we had the chance to develop a system with Clojure, ClojureScript and Datomic from the ground up.&lt;/p&gt;&lt;p&gt;This blog post series is about my attempt to implement &lt;a href='https://tonsky.me/blog/the-web-after-tomorrow/'&gt;The Web After Tomorrow&lt;/a&gt; that &lt;a href='https://twitter.com/nikitonsky'&gt;Nikita&lt;/a&gt; described in his &lt;a href='https://tonsky.me/blog/the-web-after-tomorrow/'&gt;blog post&lt;/a&gt; back in 2015.&lt;/p&gt;&lt;p&gt;In this blog post Nikita describes how modern real-time web applications should work. While the technology exists many web applications are still not fully real-time. Instead there are often multiple sections which have different levels of staleness. As an example he shows the Facebook web application:&lt;/p&gt;&lt;p&gt;&lt;img src="/img/the-web-after-tomorrow_facebook-example.png" alt="Facebook example" /&gt; (image source: https://tonsky.me/blog/the-web-after-tomorrow/)&lt;/p&gt;&lt;p&gt;There are sections like the sidebar menu which are never refreshed after the page load. While other sections like the messenger and the unread message count receive real-time updates.&lt;/p&gt;&lt;p&gt;At the end of the blog post Nikita describes how a full real-time web application might be implemented by using a combination of Datomic and DataScript. For the initial implementation of Storrito I followed this concept idea and tried to build a full real-time web application. On the server we were already using Datomic. On the client-side we added DataScript to our Reagent-based ClojureScript app.&lt;/p&gt;&lt;p&gt;To avoid the complexities of premature performance optimizations and to have a first working version ready, I took an extreme shortcut. Instead of only loading the datoms which are relevant for the current UI state, we just loaded the complete customer database on the initial page load.&lt;/p&gt;&lt;p&gt;This shortcut worked much longer than expected, since Storrito is a single-page application (SPA) and our users only needed to wait a little bit longer at the initial page load. Afterwards all changes were pushed in the form of small deltas (datoms) to the client.&lt;/p&gt;&lt;p&gt;The database portion that needed to be loaded was very small for a normal user (only a few hundred datoms). But the number of datoms grows every time the user creates or changes entities. Most of the users had to wait between 1-3 seconds at the initial page load.&lt;/p&gt;&lt;p&gt;Luckily from a business perspective there were and still are many very frequent users, which creates hundreds or even thousands of new datoms every day. They needed to wait around 20-40 seconds for the initial page load. As you can imaging loading the entire customer database had become an unacceptable option soon.&lt;/p&gt;&lt;p&gt;In the next blog post I will describe some of the ideas we had how to solve this challenge.&lt;/p&gt;</description><pubDate>Tue, 04 Jun 2019 00:00:00 +0200</pubDate></item></channel></rss>