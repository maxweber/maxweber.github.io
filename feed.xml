<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="https://maxweber.github.io/" rel="self" type="application/rss+xml"/><title>The blog of Max Weber</title><link>https://maxweber.github.io/</link><description>A blog about software and business development</description><lastBuildDate>Thu, 06 Jun 2019 10:29:46 +0200</lastBuildDate><generator>clj-rss</generator><item><guid>https://maxweber.github.io/blog/2019-06-04-approaching-the-web-after-tomorrow</guid><link>https://maxweber.github.io/blog/2019-06-04-approaching-the-web-after-tomorrow</link><title>Approaching The Web After Tomorrow - Part 1</title><description>&lt;p&gt;My current venture is &lt;a href='https://storrito.com/'&gt;Storrito.com&lt;/a&gt; where we had the chance to develop a system with Clojure, ClojureScript and Datomic from the ground up.&lt;/p&gt;&lt;p&gt;This blog post series is about my attempt to implement &lt;a href='https://tonsky.me/blog/the-web-after-tomorrow/'&gt;The Web After Tomorrow&lt;/a&gt; that &lt;a href='https://twitter.com/nikitonsky'&gt;Nikita&lt;/a&gt; described in his &lt;a href='https://tonsky.me/blog/the-web-after-tomorrow/'&gt;blog post&lt;/a&gt; back in 2015.&lt;/p&gt;&lt;p&gt;In this blog post Nikita describes how modern real-time web applications should work. While the technology exists many web applications are still not fully real-time. Instead there are often multiple sections which have different levels of staleness. As an example he shows the Facebook web application:&lt;/p&gt;&lt;p&gt; &lt;img class="post-image" src="//img/the-web-after-tomorrow_facebook-example.png"/&gt;&lt;/p&gt;&lt;p&gt;There are sections like the sidebar menu which are never refreshed after the page load. While other sections like the messenger and the unread message count receive real-time updates.&lt;/p&gt;&lt;p&gt;At the end of the blog post Nikita describes how a full real-time web application might be implemented by using a combination of Datomic and DataScript. For the initial implementation of Storrito I followed this concept idea and tried to build a full real-time web application. On the server we were already using Datomic. On the client-side we added DataScript to our Reagent-based ClojureScript app.&lt;/p&gt;&lt;p&gt;To avoid the complexities of premature performance optimizations and to have a first working version ready, I took an extreme shortcut. Instead of only loading the datoms which are relevant for the current UI state, we just loaded the complete customer database on the initial page load.&lt;/p&gt;&lt;p&gt;This shortcut worked much longer than expected, since Storrito is a single-page application (SPA) and our users only needed to wait a little bit longer at the initial page load. Afterwards all changes were pushed in the form of small deltas (datoms) to the client.&lt;/p&gt;&lt;p&gt;The database portion that needed to be loaded was very small for a normal user (only a few hundred datoms). But the number of datoms grows every time the user creates or changes entities. Most of the users had to wait between 1-3 seconds at the initial page load.&lt;/p&gt;&lt;p&gt;Luckily from a business perspective there were and still are many very frequent users, which creates hundreds or even thousands of new datoms every day. They needed to wait around 20-40 seconds for the initial page load. As you can imaging loading the entire customer database had become an unacceptable option soon.&lt;/p&gt;&lt;p&gt;In the next blog post I will describe some of the ideas we had how to solve this challenge.&lt;/p&gt;</description><pubDate>Tue, 04 Jun 2019 00:00:00 +0200</pubDate></item></channel></rss>